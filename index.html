<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Homework 11: SDE Simulator & Wiener Process</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
    :root {
        --slate-50: #f8fafc;
        --slate-100: #f1f5f9;
        --slate-200: #e2e8f0;
        --slate-400: #94a3b8;
        --slate-500: #64748b;
        --slate-600: #475569;
        --slate-700: #334155;
        --slate-800: #1e293b;
        --slate-900: #0f172a;
        --emerald-600: #059669;
        --emerald-700: #047857;
        --blue-600: #2563eb;
        --white: #ffffff;
    }

    body { 
        font-family: 'Inter', sans-serif; 
        background-color: var(--slate-50);
        color: var(--slate-800);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 0;
        line-height: 1.5;
    }

    /* --- HEADER --- */
    .site-header {
        width: 100%;
        background-color: var(--slate-900);
        padding: 2rem 1rem;
        text-align: center;
        color: var(--white);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }
    
    .site-title {
        font-weight: 800;
        font-size: 2rem;
        margin: 0 0 0.5rem 0;
        letter-spacing: -0.025em;
    }
    
    .site-subtitle {
        color: var(--slate-400);
        font-family: monospace;
        font-size: 1rem;
        max-width: 600px;
        margin: 0 auto;
    }

    .main-wrapper {
        width: 100%;
        max-width: 70rem;
        padding: 2rem 1rem;
        display: flex;
        flex-direction: column;
        gap: 2rem;
    }

    /* --- SIMULATOR CARD --- */
    .sim-card {
        background-color: var(--white);
        border-radius: 1rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        overflow: hidden;
        border: 1px solid var(--slate-200);
    }

    .controls-bar {
        padding: 1.5rem;
        background-color: var(--slate-50);
        border-bottom: 1px solid var(--slate-200);
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 1.25rem;
    }
    @media (min-width: 1024px) {
        .controls-bar { grid-template-columns: repeat(6, 1fr); }
    }

    .control-item { display: flex; flex-direction: column; }
    .control-label { 
        font-size: 0.7rem; 
        font-weight: 700; 
        color: var(--slate-500); 
        text-transform: uppercase; 
        margin-bottom: 0.35rem; 
        letter-spacing: 0.05em;
    }
    
    .control-select, .control-input { 
        border: 1px solid var(--slate-200); 
        border-radius: 0.375rem; 
        padding: 0.5rem; 
        font-size: 0.875rem; 
        background: var(--white);
        transition: border-color 0.15s;
    }
    .control-input:focus, .control-select:focus { outline: none; border-color: var(--blue-600); }

    .btn-primary { 
        background-color: var(--blue-600); 
        color: white; 
        border: none; 
        padding: 0.5rem; 
        border-radius: 0.375rem; 
        font-weight: 600; 
        cursor: pointer; 
        height: 100%; 
        margin-top: 1.2rem;
        transition: background-color 0.15s;
    }
    .btn-primary:hover { background-color: #1d4ed8; }

    /* Canvas Layout - VERTICAL STACK */
    .viz-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        border-bottom: 1px solid var(--slate-200);
    }

    .canvas-box-main {
        position: relative;
        background: white;
        width: 100%;
        height: 400px; /* Main graph height */
        border-bottom: 1px solid var(--slate-200);
    }

    .canvas-box-hist {
        position: relative;
        background: white;
        width: 100%;
        height: 250px; /* Histogram height */
        background-color: #fafafa; /* Slight distinct background */
    }
    
    /* Overlay Badges */
    .chart-badge {
        position: absolute;
        top: 12px;
        right: 12px;
        background: rgba(255, 255, 255, 0.95);
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid var(--slate-200);
        font-size: 0.75rem;
        color: var(--slate-600);
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        pointer-events: none;
    }

    .stats-panel {
        padding: 1.5rem;
        background: var(--white);
    }
    
    .stats-header {
        font-size: 0.875rem;
        font-weight: 700;
        color: var(--slate-700);
        margin-bottom: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .stats-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.875rem;
    }
    .stats-table th { background: var(--slate-50); padding: 0.75rem; font-weight: 600; text-align: left; color: var(--slate-600); border-bottom: 1px solid var(--slate-200); }
    .stats-table td { padding: 0.75rem; border-bottom: 1px solid var(--slate-100); font-family: 'Menlo', monospace; color: var(--slate-700); }
    
    .tag-match { color: var(--emerald-600); font-weight: 700; background: #dcfce7; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; }
    .tag-diff { color: #ef4444; font-weight: 700; background: #fee2e2; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; }

    /* --- ARTICLE / REPORT SECTION --- */
    .article-container {
        background: var(--white);
        padding: 3rem;
        border-radius: 1rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        border: 1px solid var(--slate-200);
    }

    .article-title {
        font-size: 2.25rem;
        font-weight: 800;
        color: var(--slate-900);
        margin-bottom: 2rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid var(--slate-100);
    }

    .article-h2 {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--slate-800);
        margin-top: 2.5rem;
        margin-bottom: 1rem;
    }

    .article-p {
        color: var(--slate-600);
        margin-bottom: 1.25rem;
        line-height: 1.7;
    }

    .article-list {
        margin-bottom: 1.5rem;
        padding-left: 1.5rem;
        color: var(--slate-600);
    }
    .article-list li { margin-bottom: 0.5rem; }

    .code-block {
        background: var(--slate-50);
        border: 1px solid var(--slate-200);
        border-radius: 0.5rem;
        padding: 1.5rem;
        margin: 1.5rem 0;
        overflow-x: auto;
        font-family: 'Menlo', monospace;
        font-size: 0.9rem;
        color: var(--slate-700);
    }

    canvas { width: 100%; height: 100%; display: block; }
</style>
</head>
<body>

<header class="site-header">
    <h1 class="site-title">Homework 11: SDE Simulator</h1>
    <div class="site-subtitle">Euler-Maruyama Simulation of Wiener Processes & General SDEs</div>
</header>

<main class="main-wrapper">
    
    <!-- SIMULATOR -->
    <section class="sim-card">
        <div class="controls-bar">
            <!-- Model Selector -->
            <div class="control-item">
                <label class="control-label">SDE Model</label>
                <select id="model" class="control-select">
                    <option value="ABM">Arithmetic (ABM)</option>
                    <option value="GBM">Geometric (GBM)</option>
                </select>
            </div>
            <div class="control-item">
                <label class="control-label">Drift (μ)</label>
                <input type="number" id="mu" value="0.5" step="0.1" class="control-input">
            </div>
            <div class="control-item">
                <label class="control-label">Volatility (σ)</label>
                <input type="number" id="sigma" value="0.5" step="0.1" class="control-input">
            </div>
            <div class="control-item">
                <label class="control-label">Time (T) / Steps (N)</label>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="number" id="T" value="1.0" class="control-input" style="width: 50%;">
                    <input type="number" id="n" value="1000" class="control-input" style="width: 50%;">
                </div>
            </div>
            <div class="control-item">
                <label class="control-label">Paths (Calc / Draw)</label>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="number" id="pathsTotal" value="1000" class="control-input" style="width: 50%;">
                    <input type="number" id="pathsDraw" value="50" class="control-input" style="width: 50%;">
                </div>
            </div>
            <div class="control-item">
                <button onclick="runSimulation()" class="btn-primary">Generate</button>
            </div>
        </div>

        <div class="viz-container">
            <!-- Top: Main Graph -->
            <div class="canvas-box-main">
                <canvas id="pathCanvas"></canvas>
                <div class="chart-badge">
                    <span style="color:#2563eb">● Path</span> &nbsp; 
                    <span style="color:#ef4444; border-bottom:1px dashed #ef4444">-- Mean</span>
                </div>
            </div>
            <!-- Bottom: Histogram -->
            <div class="canvas-box-hist">
                <canvas id="histCanvas"></canvas>
                <div class="chart-badge">Terminal Distribution (t=T)</div>
            </div>
        </div>

        <div class="stats-panel">
            <div class="stats-header">Convergence Analysis (Law of Large Numbers)</div>
            <table class="stats-table">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Theoretical Formula</th>
                        <th>Theoretical Value</th>
                        <th>Empirical Value</th>
                        <th>Convergence</th>
                    </tr>
                </thead>
                <tbody id="statsBody"></tbody>
            </table>
        </div>
    </section>

    <!-- ARTICLE / REPORT -->
    <article class="article-container">
        <h1 class="article-title">Simulation of Wiener Processes and General SDEs</h1>
        
        <p class="article-p">
            This project implements a numerical solver for Stochastic Differential Equations (SDEs) using the <strong>Euler-Maruyama method</strong>. 
            The simulator focuses on the standard Wiener Process (Brownian Motion) and extends to general forms including Arithmetic and Geometric Brownian Motion.
        </p>

        <h2 class="article-h2">1. Mathematical Models</h2>
        
        <h3 style="font-size:1.1rem; font-weight:700; margin-top:1.5rem;">1.1 Arithmetic Brownian Motion (ABM)</h3>
        <p class="article-p">
            The core requirement of Homework 11 is to simulate a Wiener process with drift. This is represented by the SDE:
        </p>
        <div class="code-block">$$ dX_t = \mu dt + \sigma dW_t $$</div>
        <p class="article-p">
            Where \( \mu \) is the constant drift and \( \sigma \) is the constant volatility. The solution \( X_t \) is normally distributed.
        </p>

        <h3 style="font-size:1.1rem; font-weight:700; margin-top:1.5rem;">1.2 Geometric Brownian Motion (GBM) - Optional Generalization</h3>
        <p class="article-p">
            To satisfy the optional requirement of handling "more general SDEs," the simulator also supports Geometric Brownian Motion. 
            Here, the drift and diffusion coefficients are <strong>linear functions of the state \(X_t\)</strong>, rather than constants:
        </p>
        <div class="code-block">$$ dS_t = \mu S_t dt + \sigma S_t dW_t $$</div>
        <p class="article-p">
            This model is fundamental in financial mathematics (Black-Scholes model) as it prevents negative values and models log-normal growth.
        </p>

        <h2 class="article-h2">2. Numerical Implementation</h2>
        
        <h3 style="font-size:1.1rem; font-weight:700; margin-top:1.5rem;">2.1 The Euler-Maruyama Method</h3>
        <p class="article-p">
            Since analytical solutions are not always available for complex SDEs, we use the Euler-Maruyama discretization scheme. For a time step \( \Delta t \):
        </p>
        <div class="code-block">$$ X_{i+1} = X_i + a(X_i, t_i)\Delta t + b(X_i, t_i)\Delta W_i $$</div>
        <p class="article-p">
            Where \( \Delta W_i = \sqrt{\Delta t} Z_i \) and \( Z_i \sim \mathcal{N}(0,1) \).
        </p>

        <h3 style="font-size:1.1rem; font-weight:700; margin-top:1.5rem;">2.2 Random Number Generation</h3>
        <p class="article-p">
            The simulator uses the <strong>Box-Muller Transform</strong> to generate independent standard normal random variables from uniform sources:
        </p>
        <div class="code-block">$$ Z = \sqrt{-2 \ln(U_1)} \cos(2\pi U_2) $$</div>

        <h2 class="article-h2">3. Verification of Results</h2>
        <p class="article-p">
            The simulation results are verified by comparing the <strong>Empirical Mean and Variance</strong> of \( N \) simulated paths against the theoretical expectations derived from Calculus.
            As seen in the "Convergence Analysis" table above, as the number of paths increases, the empirical values converge to the theoretical limits, validating the implementation of the Weak Law of Large Numbers.
        </p>

    </article>

</main>

<script>
const pathCanvas = document.getElementById('pathCanvas');
const histCanvas = document.getElementById('histCanvas');
const ctxPath = pathCanvas.getContext('2d');
const ctxHist = histCanvas.getContext('2d');

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(runSimulation, 200);
});

function generateGaussian() {
    let u = 0, v = 0;
    while(u === 0) u = Math.random(); 
    while(v === 0) v = Math.random();
    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
}

function map(val, inMin, inMax, outMin, outMax) {
    return (val - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
}

function runSimulation() {
    const model = document.getElementById('model').value;
    const mu = parseFloat(document.getElementById('mu').value);
    const sigma = parseFloat(document.getElementById('sigma').value);
    const T = parseFloat(document.getElementById('T').value);
    const n = parseInt(document.getElementById('n').value);
    const pathsTotal = parseInt(document.getElementById('pathsTotal').value);
    const pathsDraw = parseInt(document.getElementById('pathsDraw').value);
    
    pathCanvas.width = pathCanvas.parentElement.clientWidth;
    pathCanvas.height = pathCanvas.parentElement.clientHeight;
    histCanvas.width = histCanvas.parentElement.clientWidth;
    histCanvas.height = histCanvas.parentElement.clientHeight;

    const dt = T / n;
    const sqrtDt = Math.sqrt(dt);
    
    let finalValues = [];
    let trajectoriesToDraw = [];
    let yMin = Infinity, yMax = -Infinity;
    
    const X0 = (model === 'GBM') ? 100 : 0;

    for (let p = 0; p < pathsTotal; p++) {
        let current = X0;
        let path = [];
        
        const shouldDraw = p < pathsDraw;
        if(shouldDraw) path.push(current);

        for (let i = 0; i < n; i++) {
            const dW = generateGaussian() * sqrtDt;
            
            if (model === 'ABM') {
                current += mu * dt + sigma * dW;
            } else {
                current *= Math.exp( (mu - 0.5 * sigma * sigma) * dt + sigma * dW );
            }

            if(shouldDraw) path.push(current);
        }

        finalValues.push(current);
        if(shouldDraw) {
            trajectoriesToDraw.push(path);
            for(let val of path) {
                if(val < yMin) yMin = val;
                if(val > yMax) yMax = val;
            }
        }
    }

    const yRange = yMax - yMin;
    if (yRange === 0 || !isFinite(yRange)) {
        yMin = X0 - 1; yMax = X0 + 1;
    } else {
        yMin -= yRange * 0.1; 
        yMax += yRange * 0.1;
    }

    ctxPath.clearRect(0,0, pathCanvas.width, pathCanvas.height);
    drawGrid(ctxPath, pathCanvas.width, pathCanvas.height);
    
    ctxPath.lineWidth = 1;
    trajectoriesToDraw.forEach((path, idx) => {
        ctxPath.beginPath();
        ctxPath.strokeStyle = `hsla(210, 90%, 55%, 0.4)`; 
        for(let i=0; i<path.length; i++) {
            const x = map(i, 0, n, 0, pathCanvas.width);
            const y = map(path[i], yMin, yMax, pathCanvas.height, 0); 
            if(i===0) ctxPath.moveTo(x,y); else ctxPath.lineTo(x,y);
        }
        ctxPath.stroke();
    });

    ctxPath.beginPath();
    ctxPath.strokeStyle = '#ef4444';
    ctxPath.lineWidth = 2;
    ctxPath.setLineDash([5,5]);
    
    for(let i=0; i<=n; i++) {
        const t = i * dt;
        let thVal;
        if(model === 'ABM') thVal = X0 + mu * t;
        else thVal = X0 * Math.exp(mu * t);
        
        const x = map(i, 0, n, 0, pathCanvas.width);
        const y = map(thVal, yMin, yMax, pathCanvas.height, 0);
        if(i===0) ctxPath.moveTo(x,y); else ctxPath.lineTo(x,y);
    }
    ctxPath.stroke();
    ctxPath.setLineDash([]);

    drawHistogram(finalValues, histCanvas);

    updateStats(finalValues, model, mu, sigma, T, X0);
}

function drawGrid(ctx, w, h) {
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 1;
    for(let i=1; i<5; i++) {
        ctx.beginPath(); ctx.moveTo(i*w/5, 0); ctx.lineTo(i*w/5, h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i*h/5); ctx.lineTo(w, i*h/5); ctx.stroke();
    }
}

function drawHistogram(values, canvas) {
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0,0, w, h);

    let minVal = Math.min(...values);
    let maxVal = Math.max(...values);
    if(minVal === maxVal) { minVal -= 1; maxVal += 1; }
    
    const bins = 30;
    const binSize = (maxVal - minVal) / bins;
    const binCounts = new Array(bins).fill(0);
    
    values.forEach(v => {
        let binIdx = Math.floor((v - minVal) / binSize);
        if(binIdx >= bins) binIdx = bins - 1;
        if(binIdx < 0) binIdx = 0;
        binCounts[binIdx]++;
    });
    
    const maxCount = Math.max(...binCounts);
    const barWidth = w / bins;
    
    ctx.fillStyle = '#10b981'; 
    for(let i=0; i<bins; i++) {
        const height = map(binCounts[i], 0, maxCount, 0, h);
        ctx.fillRect(i * barWidth + 1, h - height, barWidth - 2, height); 
    }
}

function updateStats(values, model, mu, sigma, T, X0) {
    const N = values.length;
    const empMean = values.reduce((a,b)=>a+b,0) / N;
    const empVar = values.reduce((a,b)=>a + Math.pow(b-empMean,2),0) / N;

    let thMean, thVar, formulaMean, formulaVar;

    if (model === 'ABM') {
        thMean = X0 + mu * T;
        thVar = Math.pow(sigma, 2) * T;
        formulaMean = '\\( X_0 + \\mu T \\)';
        formulaVar = '\\( \\sigma^2 T \\)';
    } else {
        thMean = X0 * Math.exp(mu * T);
        thVar = Math.pow(X0, 2) * Math.exp(2*mu*T) * (Math.exp(Math.pow(sigma,2)*T) - 1);
        formulaMean = '\\( S_0 e^{\\mu T} \\)';
        formulaVar = '\\( S_0^2 e^{2\\mu T}(e^{\\sigma^2 T}-1) \\)';
    }

    const tbody = document.getElementById('statsBody');
    tbody.innerHTML = `
        <tr>
            <td>Mean</td>
            <td>${formulaMean}</td>
            <td>${thMean.toFixed(4)}</td>
            <td>${empMean.toFixed(4)}</td>
            <td><span class="${Math.abs(thMean-empMean)/Math.abs(thMean) < 0.05 ? 'tag-match' : 'tag-diff'}">
                ${Math.abs((empMean-thMean)/thMean*100).toFixed(2)}% error
            </span></td>
        </tr>
        <tr>
            <td>Variance</td>
            <td>${formulaVar}</td>
            <td>${thVar.toFixed(4)}</td>
            <td>${empVar.toFixed(4)}</td>
            <td><span class="${Math.abs(thVar-empVar)/Math.abs(thVar) < 0.1 ? 'tag-match' : 'tag-diff'}">
                ${Math.abs((empVar-thVar)/thVar*100).toFixed(2)}% error
            </span></td>
        </tr>
    `;
    
    if(window.MathJax) MathJax.typeset();
}

setTimeout(runSimulation, 500); 
</script>
</body>
</html>
