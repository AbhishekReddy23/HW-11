<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Homework 11 – SDE Simulator (Euler–Maruyama & Wiener Process)</title>

<!-- MathJax for formulas in the stats table -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

<style>
    :root{
        --slate-50:#f8fafc; --slate-100:#f1f5f9; --slate-200:#e2e8f0;
        --slate-400:#94a3b8; --slate-500:#64748b; --slate-600:#475569;
        --slate-700:#334155; --slate-800:#1e293b; --slate-900:#0f172a;
        --emerald-600:#059669; --blue-600:#2563eb; --white:#ffffff;
    }
    body{
        font-family:'Inter',sans-serif;
        background:var(--slate-50);
        color:var(--slate-800);
        margin:0;
        min-height:100vh;
        display:flex;
        flex-direction:column;
        align-items:center;
        line-height:1.5;
    }
    .site-header{
        width:100%; background:var(--slate-900); color:var(--white);
        padding:2rem 1rem; text-align:center;
    }
    .site-title{ font-weight:800; font-size:2rem; margin:0; }
    .site-subtitle{ color:var(--slate-400); font-family:monospace; margin-top:0.5rem; }
    .main-wrapper{ width:100%; max-width:72rem; padding:2rem 1rem; display:flex; flex-direction:column; gap:1.5rem; }

    .intro-card{
        background:var(--white);
        border-radius:0.75rem;
        padding:1.25rem 1.5rem;
        border:1px solid var(--slate-200);
        box-shadow:0 4px 6px rgba(0,0,0,0.06);
        font-size:0.9rem;
    }
    .intro-title{ font-weight:700; margin-bottom:0.35rem; }
    .intro-p{ margin:0.2rem 0; color:var(--slate-600); }

    .sim-card{ background:var(--white); border-radius:1rem; box-shadow:0 10px 15px rgba(0,0,0,0.08); border:1px solid var(--slate-200); overflow:hidden; }
    .controls-bar{ padding:1.25rem; background:var(--slate-50); border-bottom:1px solid var(--slate-200); display:grid; grid-template-columns:repeat(2,1fr); gap:1rem; }
    @media(min-width:1024px){ .controls-bar{ grid-template-columns:repeat(6,1fr);} }
    .control-item{ display:flex; flex-direction:column; }
    .control-label{ font-size:0.7rem; font-weight:700; color:var(--slate-500); text-transform:uppercase; margin-bottom:0.35rem; letter-spacing:0.05em;}
    .control-select,.control-input{ border:1px solid var(--slate-200); padding:0.5rem; border-radius:0.375rem; background:var(--white); }
    .control-input:focus,.control-select:focus{ outline:none; border-color:var(--blue-600); }
    .btn-primary{ background:var(--blue-600); color:white; border:none; padding:0.6rem; border-radius:0.375rem; font-weight:600; cursor:pointer; margin-top:1rem; }
    .btn-primary:hover{ background:#1d4ed8; }

    .viz-container{ display:flex; flex-direction:column; width:100%; border-bottom:1px solid var(--slate-200); }
    .canvas-box-main{ position:relative; background:white; width:100%; height:420px; border-bottom:1px solid var(--slate-200); }
    .canvas-box-hist{ position:relative; background:#fafafa; width:100%; height:280px; }
    .chart-badge{ position:absolute; top:12px; right:12px; background:rgba(255,255,255,0.95); padding:6px 12px; border-radius:6px; border:1px solid var(--slate-200); font-size:0.75rem; color:var(--slate-600); }
    .stats-panel{ padding:1.5rem; background:var(--white); }
    .stats-header{ font-size:0.875rem; font-weight:700; color:var(--slate-700); margin-bottom:1rem; text-transform:uppercase; letter-spacing:0.05em; }
    .stats-table{ width:100%; border-collapse:collapse; font-size:0.875rem; }
    .stats-table th{ background:var(--slate-50); padding:0.75rem; font-weight:600; text-align:left; color:var(--slate-600); border-bottom:1px solid var(--slate-200); }
    .stats-table td{ padding:0.75rem; border-bottom:1px solid var(--slate-100); font-family:Menlo,monospace; color:var(--slate-700); }
    .tag-match{ color:var(--emerald-600); font-weight:700; background:#dcfce7; padding:2px 6px; border-radius:4px; font-size:0.75rem;}
    .tag-diff{ color:#ef4444; font-weight:700; background:#fee2e2; padding:2px 6px; border-radius:4px; font-size:0.75rem; }

    canvas{ width:100%; height:100%; display:block; }
    .tip{ font-size:0.85rem; color:var(--slate-500); margin-top:0.4rem; text-align:center; }
</style>
</head>
<body>
<header class="site-header">
    <div class="site-title">Homework 11 – SDE Simulator</div>
    <div class="site-subtitle">Euler–Maruyama · Wiener Process · ABM / GBM</div>
</header>

<main class="main-wrapper">
    <section class="intro-card">
        <div class="intro-title">About this simulator</div>
        <p class="intro-p">
            This page implements the Homework 11 requirement: simulate a Wiener process (Brownian motion) using the Euler–Maruyama method,
            and optionally generalize to other SDEs such as Geometric Brownian Motion.
        </p>
        <p class="intro-p">
            Set <strong>ABM</strong> with <code>μ = 0</code>, <code>σ = 1</code>, and <code>X₀ = 0</code> to obtain a standard Wiener process.
        </p>
    </section>

    <!-- SIMULATOR CARD -->
    <section class="sim-card">
        <div class="controls-bar">
            <div class="control-item">
                <label class="control-label">SDE Model</label>
                <select id="model" class="control-select">
                    <option value="ABM">Arithmetic Brownian Motion (ABM)</option>
                    <option value="GBM">Geometric Brownian Motion (GBM)</option>
                </select>
            </div>

            <div class="control-item">
                <label class="control-label">Initial value (X₀ / S₀)</label>
                <input id="x0" class="control-input" type="number" value="0" step="0.1" />
            </div>

            <div class="control-item">
                <label class="control-label">Drift (μ)</label>
                <input id="mu" class="control-input" type="number" value="0" step="0.1" />
            </div>

            <div class="control-item">
                <label class="control-label">Volatility (σ)</label>
                <input id="sigma" class="control-input" type="number" value="1" step="0.1" />
            </div>

            <div class="control-item">
                <label class="control-label">Time (T) / Steps (N)</label>
                <div style="display:flex;gap:0.5rem">
                    <input id="T" class="control-input" type="number" value="1.0" step="0.1" style="width:50%" />
                    <input id="n" class="control-input" type="number" value="1000" step="1" style="width:50%" />
                </div>
            </div>

            <div class="control-item">
                <label class="control-label">Paths (Calc / Draw)</label>
                <div style="display:flex;gap:0.5rem">
                    <input id="pathsTotal" class="control-input" type="number" value="2000" step="1" style="width:50%" />
                    <input id="pathsDraw" class="control-input" type="number" value="60" step="1" style="width:50%" />
                </div>
            </div>

            <div class="control-item" style="grid-column:span 2;">
                <button class="btn-primary" onclick="runSimulation()">Generate</button>
                <div class="tip">Standard Wiener: model = ABM, X₀ = 0, μ = 0, σ = 1.</div>
            </div>
        </div>

        <div class="viz-container">
            <div class="canvas-box-main">
                <canvas id="pathCanvas"></canvas>
                <div class="chart-badge"><span style="color:#2563eb">● Sample paths</span> &nbsp; <span style="color:#ef4444">-- Theoretical mean</span></div>
            </div>
            <div class="canvas-box-hist">
                <canvas id="histCanvas"></canvas>
                <div class="chart-badge">Terminal distribution at t = T</div>
            </div>
        </div>

        <div class="stats-panel">
            <div class="stats-header">Convergence analysis</div>
            <table class="stats-table">
                <thead>
                    <tr><th>Metric</th><th>Theoretical Formula</th><th>Theoretical Value</th><th>Empirical Value</th><th>Convergence</th></tr>
                </thead>
                <tbody id="statsBody"></tbody>
            </table>
        </div>
    </section>
</main>

<script>
/* ========= Canvas and helpers ========= */
const pathCanvas = document.getElementById('pathCanvas');
const histCanvas = document.getElementById('histCanvas');
const ctxPath = pathCanvas.getContext('2d');
const ctxHist = histCanvas.getContext('2d');

window.addEventListener('resize', () => {
    clearTimeout(window._resizeTimer);
    window._resizeTimer = setTimeout(runSimulation, 220);
});

// Box–Muller implementation (returns one standard normal)
function generateGaussian() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2.0*Math.log(u))*Math.cos(2*Math.PI*v);
}

function map(val, inMin, inMax, outMin, outMax) {
    return (val - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
}

/* ========== Main simulation ========== */
function runSimulation(){
    const model = document.getElementById('model').value;
    const X0 = parseFloat(document.getElementById('x0').value);
    const mu = parseFloat(document.getElementById('mu').value);
    const sigma = parseFloat(document.getElementById('sigma').value);
    const T = parseFloat(document.getElementById('T').value);
    const n = parseInt(document.getElementById('n').value,10);
    const pathsTotal = parseInt(document.getElementById('pathsTotal').value,10);
    const pathsDraw = Math.min(parseInt(document.getElementById('pathsDraw').value,10), pathsTotal);

    pathCanvas.width = pathCanvas.parentElement.clientWidth;
    pathCanvas.height = pathCanvas.parentElement.clientHeight;
    histCanvas.width = histCanvas.parentElement.clientWidth;
    histCanvas.height = histCanvas.parentElement.clientHeight;

    const dt = T / n;
    const sqrtDt = Math.sqrt(dt);

    const finalValues = [];
    const trajectoriesToDraw = [];
    let yMin = Infinity, yMax = -Infinity;

    for (let p = 0; p < pathsTotal; p++){
        let current = X0;
        const shouldDraw = p < pathsDraw;
        const path = shouldDraw ? [current] : null;

        for (let i = 0; i < n; i++){
            const dW = generateGaussian() * sqrtDt;
            if (model === 'ABM'){
                // Euler–Maruyama step
                current = current + mu * dt + sigma * dW;
            } else {
                // GBM exact step
                current = current * Math.exp( (mu - 0.5 * sigma * sigma) * dt + sigma * dW );
            }
            if (shouldDraw) path.push(current);
        }

        finalValues.push(current);
        if (shouldDraw){
            trajectoriesToDraw.push(path);
            for (let v of path){ if (v < yMin) yMin = v; if (v > yMax) yMax = v; }
        }
    }

    if (!isFinite(yMin) || !isFinite(yMax) || yMin === Infinity || yMax === -Infinity) {
        yMin = X0 - 1;
        yMax = X0 + 1;
    }
    let yRange = yMax - yMin;
    if (yRange === 0) { yMin -= 1; yMax += 1; yRange = 2; }
    else { yMin -= yRange*0.08; yMax += yRange*0.08; }

    ctxPath.clearRect(0,0,pathCanvas.width,pathCanvas.height);
    drawGrid(ctxPath,pathCanvas.width,pathCanvas.height);

    ctxPath.lineWidth = 1;
    trajectoriesToDraw.forEach(path => {
        ctxPath.beginPath();
        ctxPath.strokeStyle = `hsla(210,90%,55%,0.35)`;
        for (let i=0; i<path.length; i++){
            const x = map(i,0,n,0,pathCanvas.width);
            const y = map(path[i], yMin, yMax, pathCanvas.height, 0);
            if (i===0) ctxPath.moveTo(x,y); else ctxPath.lineTo(x,y);
        }
        ctxPath.stroke();
    });

    // theoretical mean line
    ctxPath.beginPath();
    ctxPath.setLineDash([6,6]);
    ctxPath.lineWidth = 2;
    ctxPath.strokeStyle = '#ef4444';
    for (let i=0;i<=n;i++){
        const t = i*dt;
        let thVal;
        if (model === 'ABM') thVal = X0 + mu * t;
        else thVal = X0 * Math.exp(mu * t);
        const x = map(i,0,n,0,pathCanvas.width);
        const y = map(thVal, yMin, yMax, pathCanvas.height, 0);
        if (i===0) ctxPath.moveTo(x,y); else ctxPath.lineTo(x,y);
    }
    ctxPath.stroke();
    ctxPath.setLineDash([]);

    drawHistogram(finalValues, histCanvas, model, X0, mu, sigma, T);
    updateStats(finalValues, model, mu, sigma, T, X0);
}

function drawGrid(ctx,w,h){
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 1;
    for (let i=1;i<5;i++){
        ctx.beginPath(); ctx.moveTo(i*w/5,0); ctx.lineTo(i*w/5,h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,i*h/5); ctx.lineTo(w,i*h/5); ctx.stroke();
    }
}

function drawHistogram(values, canvas, model, X0, mu, sigma, T){
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    if (!values.length) return;

    let minVal = Math.min(...values);
    let maxVal = Math.max(...values);
    if (minVal === maxVal) { minVal -= 1; maxVal += 1; }

    const bins = 40;
    const binSize = (maxVal - minVal) / bins;
    const binCounts = new Array(bins).fill(0);

    values.forEach(v => {
        let idx = Math.floor((v - minVal) / binSize);
        if (idx < 0) idx = 0;
        if (idx >= bins) idx = bins - 1;
        binCounts[idx]++;
    });

    const maxCount = Math.max(...binCounts);
    const barWidth = w / bins;

    ctx.fillStyle = '#10b981';
    for (let i=0;i<bins;i++){
        const height = map(binCounts[i], 0, maxCount, 0, h);
        ctx.fillRect(i*barWidth + 1, h - height, barWidth - 2, height);
    }

    // overlay theoretical normal pdf for ABM
    if (model === 'ABM'){
        const thMean = X0 + mu * T;
        const thVar = sigma * sigma * T;
        if (isFinite(thMean) && isFinite(thVar) && thVar > 0){
            function normalPdf(x, m, v){
                return Math.exp(-0.5 * Math.pow((x-m)/Math.sqrt(v),2)) / (Math.sqrt(2*Math.PI*v));
            }
            const maxPdf = normalPdf(thMean, thMean, thVar);
            const scale = maxCount / maxPdf; // not used explicitly but conceptually

            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#ef4444';
            for (let px=0; px<=w; px++){
                const xVal = minVal + (px/w) * (maxVal - minVal);
                const pdfVal = normalPdf(xVal, thMean, thVar);
                const y = h - map(pdfVal, 0, maxPdf, 0, h);
                if (px === 0) ctx.moveTo(px, y); else ctx.lineTo(px, y);
            }
            ctx.stroke();
        }
    }
}

function updateStats(values, model, mu, sigma, T, X0){
    const N = values.length;
    const empMean = values.reduce((s,v)=>s+v,0)/N;
    const empVar = values.reduce((s,v)=>s + Math.pow(v - empMean,2),0) / N;

    let thMean = NaN, thVar = NaN, formulaMean = '', formulaVar = '';

    if (model === 'ABM'){
        thMean = X0 + mu * T;
        thVar = sigma * sigma * T;
        formulaMean = '\\(X_0 + \\mu T\\)';
        formulaVar = '\\(\\sigma^2 T\\)';
    } else {
        thMean = X0 * Math.exp(mu * T);
        thVar = Math.pow(X0,2) * Math.exp(2*mu*T) * (Math.exp(sigma*sigma*T) - 1);
        formulaMean = '\\(S_0 e^{\\mu T}\\)';
        formulaVar = '\\(S_0^2 e^{2\\mu T}(e^{\\sigma^2 T}-1)\\)';
    }

    function pctError(emp, th, isMean){
        if (!isFinite(th) || Math.abs(th) < 1e-12) {
            return { display: (Math.abs(emp - th)).toFixed(6) + ' (abs)', isMatch: Math.abs(emp - th) < 1e-6 };
        } else {
            const p = Math.abs((emp - th) / th) * 100;
            return { display: p.toFixed(2) + '%', isMatch: p < (isMean ? 5 : 10) };
        }
    }

    const meanErr = pctError(empMean, thMean, true);
    const varErr = pctError(empVar, thVar, false);

    const tbody = document.getElementById('statsBody');
    tbody.innerHTML = `
        <tr>
            <td>Mean</td>
            <td>${formulaMean}</td>
            <td>${isFinite(thMean) ? thMean.toFixed(6) : 'N/A'}</td>
            <td>${empMean.toFixed(6)}</td>
            <td><span class="${meanErr.isMatch ? 'tag-match' : 'tag-diff'}">${meanErr.display}</span></td>
        </tr>
        <tr>
            <td>Variance</td>
            <td>${formulaVar}</td>
            <td>${isFinite(thVar) ? thVar.toFixed(6) : 'N/A'}</td>
            <td>${empVar.toFixed(6)}</td>
            <td><span class="${varErr.isMatch ? 'tag-match' : 'tag-diff'}">${varErr.display}</span></td>
        </tr>
    `;

    if (window.MathJax) MathJax.typeset();
}

setTimeout(runSimulation, 400);
</script>
</body>
</html>
